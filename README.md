# CICD_GCP_Pipileine

A Continous Integration and Delivery  pipeline that automatically builds a container image from committed code, stores the image in Artifact Registry, updates a Kubernetes manifest in a Git repository, and deploys the application to Google Kubernetes Engine using that manifest.

The following documentation is modified version of a resource in certification
source :- Google IT Automation with Python Professional Certificate-> Configuration Management and the Cloud -> Final Module Lab 

![alt text](https://cdn.qwiklabs.com/qEN8Qxr82h1FkL8DhD5sqJmblM11i7JjhZv14OGahr0%3D)


## Setup and requirements
 - You Must have an active Google Cloud Account. (Charges May apply for usage of cloud resources so carefully check if the used resources are available for free for you or not)
 - Open your Google Cloud Dashboard
 - Click Activate Cloud Shell Activate Cloud Shell icon at the top of the Google Cloud console.
 - Create a new project

## Initialize resources
 - In Cloud Shell, set your project ID and project number. Save them as PROJECT_ID and PROJECT_NUMBER variables:
```
export PROJECT_ID=$(gcloud config get-value project)
export PROJECT_NUMBER=$(gcloud projects describe $PROJECT_ID --format='value(projectNumber)')
export REGION=
gcloud config set compute/region $REGION
```
 - Run the following command to enable the APIs for GKE, Cloud Build, Cloud Source Repositories and Container Analysis:

```
gcloud services enable container.googleapis.com \
    cloudbuild.googleapis.com \
    sourcerepo.googleapis.com \
    containeranalysis.googleapis.com
```
 - Create an Artifact Registry Docker repository named my-repository in the region of project to store your container images
```
 gcloud artifacts repositories create my-repository \
  --repository-format=docker \
  --location=$REGION
```
 - Create a GKE cluster to deploy the sample application of this lab:
```
gcloud container clusters create hello-cloudbuild --num-nodes 1 --region $REGION
```

## Create the Git repositories in Cloud Source Repositories
 - Follow the commands
```
git config --global user.email "you@example.com"
git config --global user.name "Your Name"
gcloud source repos create hello-cloudbuild-app
gcloud source repos create hello-cloudbuild-env

```
 - Now You have to manually create 2 repositories on your configured git account
 - The first repo hello-cloudbuild-app should contain all the files mentioned in given repo
 - The second repo hello-cloudbuild-env should contain 2 chains candidate and production each of whose code is available in given repo.
 - After cloning the repos properly type the following

```
cd ~/hello-cloudbuild-app
export REGION="REGION"
sed -i "s/us-central1/$REGION/g" cloudbuild.yaml
sed -i "s/us-central1/$REGION/g" cloudbuild-delivery.yaml
sed -i "s/us-central1/$REGION/g" cloudbuild-trigger-cd.yaml
sed -i "s/us-central1/$REGION/g" kubernetes.yaml.tpl
PROJECT_ID=$(gcloud config get-value project)
git remote add google "https://source.developers.google.com/p/${PROJECT_ID}/r/hello-cloudbuild-app"

```

 PLEASE FOLLOW THE FURTHER INSTRUCTIONS AS SHOWN :- 

## 3. Create a container image with Cloud Build
The code you cloned already contains the following Dockerfile.
With this Dockerfile, you can create a container image with Cloud Build and store it in Artifact Registry.

In Cloud Shell, create a Cloud Build build based on the latest commit with the following command: 
```
cd ~/hello-cloudbuild-app
COMMIT_ID="$(git rev-parse --short=7 HEAD)"
gcloud builds submit --tag="${REGION}-docker.pkg.dev/${PROJECT_ID}/my-repository/hello-cloudbuild:${COMMIT_ID}" .
```

Cloud Build streams the logs generated by the creation of the container image to your terminal when you execute this command.

After the build finishes, in the Cloud console go to Artifact Registry > Repositories to verify that your new container image is indeed available in Artifact Registry. Click my-repository.
Artifact Registry


## 4. Create the Continuous Integration (CI) pipeline
In this task, you will configure Cloud Build to automatically run a small unit test, build the container image, and then push it to Artifact Registry. Pushing a new commit to Cloud Source Repositories triggers this pipeline automatically. The cloudbuild.yaml file already included in the code is the pipeline's configuration.

Architecture

In the Cloud console, go to Cloud Build > Triggers.
Click Create Trigger
In the Name field, type hello-cloudbuild.
Under Event, select Push to a branch.
Under Source, select hello-cloudbuild-app as your Repository and .* (any branch) as your Branch.
Under Build configuration, select Cloud Build configuration file.
In the Cloud Build configuration file location field, type cloudbuild.yaml after the /.
Click Create.
Create Trigger

When the trigger is created, return to the Cloud Shell. You now need to push the application code to Cloud Source Repositories to trigger the CI pipeline in Cloud Build.

To start this trigger, run the following command:
```
cd ~/hello-cloudbuild-app
git add .
git commit -m "Type Any Commit Message here"
git push google master
```
In the Cloud console, go to Cloud Build > Dashboard.
You should see a build running or having recently finished. You can click on the build to follow its execution and examine its logs.
Dashboard
Click Check my progress to verify the objective.
Create the Continuous Integration (CI) Pipeline

## 5. Create the Test Environment and CD pipeline
Cloud Build is also used for the continuous delivery pipeline. The pipeline runs each time a commit is pushed to the candidate branch of the hello-cloudbuild-env repository. The pipeline applies the new version of the manifest to the Kubernetes cluster and, if successful, copies the manifest over to the production branch. This process has the following properties:

The candidate branch is a history of the deployment attempts.
The production branch is a history of the successful deployments.
You have a view of successful and failed deployments in Cloud Build.
You can rollback to any previous deployment by re-executing the corresponding build in Cloud Build. A rollback also updates the production branch to truthfully reflect the history of deployments.
Next you will modify the continuous integration pipeline to update the candidate branch of the hello-cloudbuild-env repository, triggering the continuous delivery pipeline.

Grant Cloud Build access to GKE
To deploy the application in your Kubernetes cluster, Cloud Build needs the Kubernetes Engine Developer Identity and Access Management role.

In Cloud Shell execute the following command: 
```
PROJECT_NUMBER="$(gcloud projects describe ${PROJECT_ID} --format='get(projectNumber)')"
gcloud projects add-iam-policy-binding ${PROJECT_NUMBER} \
--member=serviceAccount:${PROJECT_NUMBER}@cloudbuild.gserviceaccount.com \
--role=roles/container.developer
```
You need to initialize the hello-cloudbuild-env repository with two branches (production and candidate) and a Cloud Build configuration file describing the deployment process.

The first step is to clone the hello-cloudbuild-env repository and create the production branch. It is still empty.

In Cloud Shell execute the following command:
```
cd ~
gcloud source repos clone hello-cloudbuild-env
cd ~/hello-cloudbuild-env
git checkout -b production
cd ~/hello-cloudbuild-env
cp ~/hello-cloudbuild-app/cloudbuild-delivery.yaml ~/hello-cloudbuild-env/cloudbuild.yaml
git add .
git commit -m "Create cloudbuild.yaml for deployment"
```
The cloudbuild-delivery.yaml file describes the deployment process to be run in Cloud Build. It has two steps:

Cloud Build applies the manifest on the GKE cluster.
If successful, Cloud Build copies the manifest on the production branch.
Create a candidate branch and push both branches for them to be available in Cloud Source Repositories: 
```
git checkout -b candidate
git push origin production
git push origin candidate 
```

Grant the Source Repository Writer IAM role to the Cloud Build service account for the hello-cloudbuild-env repository:
```
PROJECT_NUMBER="$(gcloud projects describe ${PROJECT_ID} \
--format='get(projectNumber)')"
cat >/tmp/hello-cloudbuild-env-policy.yaml <<EOF
bindings:
- members:
  - serviceAccount:${PROJECT_NUMBER}@cloudbuild.gserviceaccount.com
  role: roles/source.writer
EOF
```
Create the trigger for the continuous delivery pipeline


In the Cloud console, go to Cloud Build > Triggers.
Click Create Trigger.
In the Name field, type hello-cloudbuild-deploy.
Under Event, select Push to a branch.
Under Source, select hello-cloudbuild-env as your Repository and ^candidate$ as your Branch.
Under Build configuration, select Cloud Build configuration file.
In the Cloud Build configuration file location field, type cloudbuild.yaml after the /.
Click Create.
Create Trigger

Modify the continuous integration pipeline to trigger the continuous delivery pipeline.
Next, add some steps to the continuous integration pipeline that will generate a new version of the Kubernetes manifest and push it to the hello-cloudbuild-env repository to trigger the continuous delivery pipeline.

Copy the extended version of the cloudbuild.yaml file for the app repository:
```
cd ~/hello-cloudbuild-app
cp cloudbuild-trigger-cd.yaml cloudbuild.yaml
```
The cloudbuild-trigger-cd.yaml is an extended version of the cloudbuild.yaml file. It adds the steps below: they generate the new Kubernetes manifest and trigger the continuous delivery pipeline.

This pipeline uses a simple sed to render the manifest template. In reality, you will benefit from using a dedicated tool such as kustomize or skaffold. They allow for more control over the rendering of the manifest templates.
Commit the modifications and push them to Cloud Source Repositories:
```
cd ~/hello-cloudbuild-app
git add cloudbuild.yaml
git commit -m "Trigger CD pipeline"
git push google master
```
This triggers the continuous integration pipeline in Cloud Build.
Click Check my progress to verify the objective.
Create the Test Environment and CD Pipeline

## 6. Review Cloud Build Pipeline

In the Cloud console, go to Cloud Build > Dashboard.
Click into the hello-cloudbuild-app trigger to follow its execution and examine its logs. The last step of this pipeline pushes the new manifest to the hello-cloudbuild-env repository, which triggers the continuous delivery pipeline.
Build History

Return to the main Dashboard.
You should see a build running or having recently finished for the hello-cloudbuild-env repository. You can click on the build to follow its execution and examine its logs.
Cloud Build Dashboard

Task 7. Test the complete pipeline
The complete CI/CD pipeline is now configured. Test it from end to end.

In the Cloud console, go to Kubernetes Engine > Gateways, Services & Ingress.
There should be a single service called hello-cloudbuild in the list. It has been created by the continuous delivery build that just ran.

Click on the endpoint for the hello-cloudbuild service. You should see "Hello World!". If there is no endpoint, or if you see a load balancer error, you may have to wait a few minutes for the load balancer to be completely initialized. Click Refresh to update the page if needed.
App 1 Hello World!

In Cloud Shell, replace "Hello World" with "Hello Cloud Build", both in the application and in the unit test:
```
cd ~/hello-cloudbuild-app
sed -i 's/Hello World/Hello Cloud Build/g' app.py
sed -i 's/Hello World/Hello Cloud Build/g' test_app.py
```
Commit and push the change to Cloud Source Repositories:
```
git add app.py test_app.py
git commit -m "Hello Cloud Build"
git push google master
```
This triggers the full CI/CD pipeline.

After a few minutes, reload the application in your browser. You should now see "Hello Cloud Build!".

Congrats It's working !



